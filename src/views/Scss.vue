<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    <main id="main">
      <div class="p">
        PPPPPPP
        <div class="redbox chrome">
          redbox
          <p class="header"></p>
        </div>
        <div class="redbox-hhh">
          redbox
        </div>
      </div>
    </main>
    <div class="seriousError">error</div>
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped lang="scss">
// @debug 10em + 12em;
// Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：
// @import "rounded-corners", "text-shadow";
$width: 500px;

// 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：
// $family: unquote("Droid+Sans");
// @import url("http://fonts.googleapis.com/css?family=\#{$family}");

.foo.bar .baz.bang, .bip.qux {
  $selector: &;
}

@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  } @else {
    a {
      color: red;
    }
  }
}

// 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值
// 变量是 null 空值时将视为未被 !default 赋值
$content: null;
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  @import "@/assets/_colors";
  content: $content;
  // new-content: $new-content;

  @media screen and (min-width: 800px) {
    background-color: #f0f;
  }

  $media: screen;
  $feature: -webkit-min-device-pixel-ration;
  $value: 1.5;

  @media #{$media} and ($feature: $value) {
    width:800px;
  }

  .p {
    // 属性嵌套 (Nested Properties)
    width: $width;
    font: {
      family: fantasy;
      size: 3em;
      weight: bold;
    }

    $version: "1.2.3";
    $author: "mazi";
    /* This CSS is generated by #{$author} Framework version #{$version}. */

    // 命名空间也可以包含自己的属性值
    font: 5em {
      family: fantasy;
      weight: bold;
    }

    // /* */会 被完整输出到编译后的 CSS 文件中，而//则不会
    // 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息

    color: #0f0;
    // 关系运算 <, >, <=, >= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型
    // width: 1in + 8pt;
    width: 97%;

    font: 10px / 8px;
    width: $width/2;
    width: round($number: 1.5) / 2;
    height: (500px / 2);
    margin-left: 5px + 8px / 2px;

    // 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值
    // color: #010203 + #040506; // 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09
    // color: #010203 * 2;
    // 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值
    // color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
    // 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整
    $translucent-red: rgba(255, 0, 0, 0.5);
    $green: #0f0;
    color: opacify($color: $translucent-red, $amount: 0.25);
    background-color: transparentize($color: $translucent-red, $amount: 0.25);
    filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');

    $value: null;
    content: "I ate #{$value} pies";

    // string operate
    cursor: e + -resize;

    // 如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号
    content: "Foo " + Bar;
    font-family: sans- + "serif";

    // 运算表达式与其他值连用时，用空格做连接符
    margin: 3px + 4px auto;

    // 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值
    contain: "I ate #{5 + 10} pies";

    // 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹
    $font-size: 12px;
    $line-height: 30px;
    font: #{$font-size}/#{$line-height};

    .redbox {
      // 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明
      $c: blue !global;
      background-color: #f00;
      color: $c;
      transition: .5s;

      &:hover {
        background-color: green;
        color: #fff;
      }

      &-hhh {
        width: 1em + (2em * 3);
        border: 1px solid hsl(0, 100%, 50%);

        // 关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用
        color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
      }
    }

    border: 1px solid $c;

    // sassscript types
    // 数字，1, 2, 13, 10px
    // 字符串，有引号字符串与无引号字符串，"foo", 'bar', baz
    // 颜色，blue, #04a3f9, rgba(255,0,0,0.5)
    // 布尔型，true, false
    // 空值，null
    // 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
    // maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)
    @mixin chrome-message($selector) {
      .chrome #{$selector}:before {
        content: "Hi, Chrome users";
      }
    }
    @include chrome-message(".header");
  }
}

.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.intrusion {
  background-image: url("~@/assets/logo.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}

// Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^="http://"]
.hoverlink {
  @extend a:hover;
}
.comment a.user:hover {
  font-weight: bold;
}
a:hover {
  text-decoration: underline;
}

.error {
  border: 1px #f00;
  background-color: #fdd;
}
.attention {
  font-size: 3em;
  background-color: #ff0;
}
.seriousError {
  // @extend .error;
  // @extend .attention;
  @extend .error, .attention;
  border-width: 3px;
}

// 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列
#fake-links .link {
  @extend a;
}
a {
  color: blue;
  &:hover {
    text-decoration: underline;
  }
}

// @extend-Only 选择器
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
.notice {
  @extend %extreme;
}

// 如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器
a.important {
  @extend .notice !optional;
}

@media print {
  .err {
    border: 1px #f00;
    background-color: #fdd;
  }
  .seriousErr {
    @extend .err;
    border-width: 3px;
  }
}

.parent {
  @at-root .child {
    color: #ccc;
  }
}

@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
    @at-root (with: media) {
      color: red;
    }
  }
}

$type: monster;
h1 {
  // 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码
  // @if 1 + 1 == 2 { border: 1px solid; }
  // @if 5 < 3 { border: 2px solid; }
  // @if null { border: 3px double; }
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}

// @for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。
// 这个指令包含两种格式：@for $var from <start> through <end>，或者 @for $var from <start> to <end>，
// 区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 <start> 与 <end> 的值，而使用 to 时条件范围只包含 <start> 的值不包含 <end> 的值。
// 另外，$var 可以是任何变量，比如 $i；<start> 和 <end> 必须是整数值
@for $i from 1 through 3 {
  .item-#{$i} {
    width: 2em * $i;
  }
}

@for $i from 1 to 3 {
  .item#{$i}-#{$i} {
    width: 2em * $i;
  }
}

@each $animal in 0, 1, 2, 3 {
  .#{$animal}-icon {
    // background-color: #f00 + $animal;
  }
}

@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}

$i: 6;
@while $i > 0 {
  .item-#{$i} {
    width: 2em * $i;
    $i: $i - 2;
  }
}

// mixin
@mixin clearfix {
  display: inline-block;
  &::after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html & {
    height: 1px;
  }
}

.hello {
  @include clearfix;
}

@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;

@mixin compound {
  @include clearfix;
  @include silly-links;
}

@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
.hello {
  @include sexy-border(blue);
  @include sexy-border($color: blue);
}
.hello p {
  @include sexy-border($color: #0f0, $width: 2in);
}

@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}
.hello {
  @include box-shadow(0px 40px 5px #666, 2px 6px 10px #999);
}

@mixin colors($text, $bg, $border) {
  color: $text;
  background-color: $bg;
  border-color: $border;
}
$values: #f00, #0f0, #00f;
.redbox-hhh {
  @include colors($values...);
}

@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #main {
    background-color: url(~@/assets/logo.png);
  }
}


// Variable Scope
$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
// 编译结果
// .colors {
//   @include colors { color: $color; }
// }
// .colors {
//   background-color: blue;
//   color: white;
//   border-color: blue;
// }

// function
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}
#main {
  width: grid-width($n: 5);
}
</style>
